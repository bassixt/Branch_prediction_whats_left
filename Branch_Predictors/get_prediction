#ifdef _get_prediction_
#define _get_prediction_

#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <inttypes.h>
#include <stdbool.h>
#include <stdlib.h>
#include <common_var.h>
#include <predictor.h>

#define BUFFER_SIZE 126
#define ITERA 42000
#define SIZE 3
#define INITIAL_VALUE 3
#define INITIAL_ADDRESS 0
#define INPUT_FILE "test.txt"
#define OUTPUT_FILE "results.txt"
#define NUMTAGTABLES 4



bool get_prediction(uint64_t PC, predictor * tage) //dobbiamo passare la classe predictor
{

bool basePrediction;
UINT32 bimodalIndex   = (PC) % (predictor.numBimodalEntries);
UINT32 bimodalCounter = bimodal[bimodalIndex]; 

if(bimodalCounter > BIMODAL_CTR_MAX/2){
    basePrediction =  1; 
  }else{
    basePrediction =  0; 
}

     // Hash to get tag includes info about bank, pc and global history compressed
     // formula given in PPM paper 
     // pc[9:0] xor CSR1 xor (CSR2 << 1)

 for(int i = 0; i < NUMTAGTABLES; i++)
{ 
     predictor.tag[i] = PC ^ predictor.tagComp[0][i].compHist ^ (predictor.tagComp[1][i].compHist << 1);
    // These need to be masked
    // 9 bit tags for T0 and T1 // 8 bit tags for T2 and T3
}

predictor.tag[0] &= ((1<<9)-1);
predictor.tag[1] &= ((1<<9)-1);
predictor.tag[2] &= ((1<<9)-1);
predictor.tag[3] &= ((1<<9)-1);

// How to get index for each bank ??
// bank 1
// Hash of PC, PC >> index length important , GHR geometric, path info

UINT32 index_mask = ((1<<TAGPREDLOG) - 1);

predictor.indexTagPred[0] = PC ^ (PC >> TAGPREDLOG) ^ predictor.indexComp[0].compHist ^ predictor.PHR ^ (predictor.PHR >> TAGPREDLOG);
predictor.indexTagPred[1] = PC ^ (PC >> (TAGPREDLOG - 1)) ^ predictor.indexComp[1].compHist ^ (predictor.PHR );
predictor.indexTagPred[2] = PC ^ (PC >> (TAGPREDLOG - 2)) ^ predictor.indexComp[2].compHist ^ (predictor.PHR & 31);
predictor.indexTagPred[3] = PC ^ (PC >> (TAGPREDLOG - 3)) ^ predictor.indexComp[3].compHist ^ (predictor.PHR & 7);

for(int i = 0; i < NUMTAGTABLES; i++)
{
    predictor.indexTagPred[i] = predictor.indexTagPred[i] & index_mask;
           
}

// get two predictions prime and alt (alternate)
predictor.primePred = -1;
predictor.altPred = -1;
predictor.primeBank = NUMTAGTABLES;
predictor.altBank = NUMTAGTABLES;


// See if any tag matches
// T0 with longest history so if hit that awesome

       for(int iterator = 0; iterator < NUMTAGTABLES; iterator++)
       {
           
           
            if(predictor.tagPred[iterator][predictor.indexTagPred[iterator]].tag == predictor.tag[iterator])
            {
                predictor.primeBank = iterator;
                break;
            }  
       }      
            for(int iterator = predictor.primeBank + 1; iterator < NUMTAGTABLES; iterator++)
            {
                if(predictor.tagPred[iterator][predictor.indexTagPred[iterator]].tag == tag[predictor.iterator])
                {
                    predictor.altBank = iterator;
                    break;
                }  
            }    
            
       
       
    if(predictor.primeBank < NUMTAGTABLES)
    {        
       if(predictor.altBank == NUMTAGTABLES)
       {
           predictor.altPred = basePrediction;
       }
       else
       {
           if(predictor.tagPred[altBank][predictor.indexTagPred[predictor.altBank]].ctr >= TAGPRED_CTR_MAX/2)
                predictor.altPred = TAKEN;
            else 
                predictor.altPred = NOT_TAKEN;
       }
        
        if((predictor.tagPred[primeBank][predictor.indexTagPred[predictor.primeBank]].ctr  != 3) ||(predictor.tagPred[predictor.primeBank][predictor.indexTagPred[predictor.primeBank]].ctr != 4 ) || (predictor.tagPred[predictor.primeBank]predictor.[indexTagPred[primeBank]].usefulBits != 0) || (predictor.altBetterCount < 8))
        {
            if(predictor.tagPred[predictor.primeBank][predictor.indexTagPred[predictor.primeBank]].ctr >= TAGPRED_CTR_MAX/2)
                predictor.primePred = TAKEN;
            else 
                predictor.primePred = NOT_TAKEN;
            return predictor.primePred;
        }
        else
        {
            return predictor.altPred;
        }
    }
    else
    {
        predictor.altPred = basePrediction;
        return predictor.altPred;
    }
}


#endif
